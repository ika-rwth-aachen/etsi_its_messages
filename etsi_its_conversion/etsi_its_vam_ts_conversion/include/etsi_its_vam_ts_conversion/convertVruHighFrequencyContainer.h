/** ============================================================================
MIT License

Copyright (c) 2023-2025 Institute for Automotive Engineering (ika), RWTH Aachen University

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
============================================================================= */

/** Auto-generated by https://github.com/ika-rwth-aachen/etsi_its_messages -----
python3 \
  utils/codegen/codegen-py/asn1ToConversionHeader.py \
  asn1/raw/vam-ts103300_3/VAM-PDU-Descriptions.asn \
  asn1/patched/vam-ts103300_3/cdd/ETSI-ITS-CDD.asn \
  -t \
  vam_ts \
  -o \
  etsi_its_conversion/etsi_its_vam_ts_conversion/include/etsi_its_vam_ts_conversion
----------------------------------------------------------------------------- */

/** ASN.1 Definition -----------------------------------------------------------
*
 * @details VruHighFrequencyContainer
 * The VRU HF container of the VAM contains potentially fast-changing status information of the VRU ITS-S.
 * It includes the following components (setting indications are specified in clause 7.3.3 of TS 103 300-3): 
 * 
 * @field heading: heading and heading confidence of the originating VRU with regards to the true north. 
 * @field speed: speed in moving direction and speed confidence of the originating VRU.   
 * @field longitudinalAcceleration: longitudinal acceleration of the originating VRU. 
 * @field curvature: related to the actual trajectory of the originating VRU vehicle.
          _(recommended for VRU Profile 2)_
 * @field curvatureCalculationMode: indicates whether vehicle yaw-rate is used in the calculation of
 *        the curvature of the VRU vehicle ITS-S that originates the VAM. _(recommended for VRU Profile 2)_
 * @field yawRate: yaw rate of originating VRU vehicle. _(recommended for VRU Profile 2)_
 * @field lateralAcceleration: originating VRU lateral acceleration in the street plane.
 *        This field shall be present if the data is available at the originating ITS-S. _(recommended for VRU Profile 2)_ 
 * @field verticalAcceleration: vertical acceleration of the originating VRU.
 *        This field shall be present if the data is available at the originating ITS-S.
 * @field vruLanePosition: lane position of the referencePosition of a VRU, which is either a VRU-specific non-traffic lane  
 *        or a standard traffic lane. This field shall be present if the data is available at the originating ITS-S.
 * @field environment: provides contextual awareness of the VRU among other road users.
 *        This field shall be present only if the data is available at the originating ITS-S.
 * @field movementControl: indicates the mechanism used by the VRU to control the  longitudinal movement of the VRU vehicle.
 *        This field shall be present only if the data is available at the originating ITS-S. _(recommended for VRU Profile 2)_
 * @field orientation : complements the dimensions of the VRU vehicle by defining the angle of the VRU vehicle longitudinal
 *        axis with regards to the WGS84 north. _(recommended for VRU Profile 2)_
 * @field rollAngle: provides the angle and angle accuracy between the ground plane and the current orientation of a vehicle's
 *        y-axis with respect to the ground plane about the x-axis according to the ISO 8855. 
 *        This field shall be present only if the data is available at the originating ITS-S. _(recommended for VRU Profile 2)_
 * @field deviceUsage: provides indications from the personal device about the potential 
 *        activity of the VRU. This field shall be present only if the data is available at the originating ITS-S.
 *        _(recommended for VRU Profile 1)_
 * 
 * @category: VRU information
 * @revision: V2.2.1
 *
    VruHighFrequencyContainer ::= SEQUENCE {
        heading                  Wgs84Angle,  
        speed                    Speed, 
        longitudinalAcceleration LongitudinalAcceleration, 
        curvature                Curvature OPTIONAL, 
        curvatureCalculationMode CurvatureCalculationMode OPTIONAL, 
        yawRate                  YawRate OPTIONAL, 
        lateralAcceleration      LateralAcceleration OPTIONAL, 
        verticalAcceleration     VerticalAcceleration OPTIONAL, 
        vruLanePosition          GeneralizedLanePosition OPTIONAL, 
        environment              VruEnvironment OPTIONAL,
        movementControl          VruMovementControl OPTIONAL,
        orientation              Wgs84Angle OPTIONAL, 
        rollAngle                CartesianAngle OPTIONAL,  
        deviceUsage              VruDeviceUsage OPTIONAL,
        ...
    }
----------------------------------------------------------------------------- */

#pragma once

#include <etsi_its_vam_ts_coding/vam_ts_VruHighFrequencyContainer.h>
#include <etsi_its_vam_ts_conversion/convertCartesianAngle.h>
#include <etsi_its_vam_ts_conversion/convertCurvature.h>
#include <etsi_its_vam_ts_conversion/convertCurvatureCalculationMode.h>
#include <etsi_its_vam_ts_conversion/convertGeneralizedLanePosition.h>
#include <etsi_its_vam_ts_conversion/convertLateralAcceleration.h>
#include <etsi_its_vam_ts_conversion/convertLongitudinalAcceleration.h>
#include <etsi_its_vam_ts_conversion/convertSpeed.h>
#include <etsi_its_vam_ts_conversion/convertVerticalAcceleration.h>
#include <etsi_its_vam_ts_conversion/convertVruDeviceUsage.h>
#include <etsi_its_vam_ts_conversion/convertVruEnvironment.h>
#include <etsi_its_vam_ts_conversion/convertVruMovementControl.h>
#include <etsi_its_vam_ts_conversion/convertWgs84Angle.h>
#include <etsi_its_vam_ts_conversion/convertYawRate.h>
#ifdef ROS1
#include <etsi_its_vam_ts_msgs/VruHighFrequencyContainer.h>
namespace vam_ts_msgs = etsi_its_vam_ts_msgs;
#else
#include <etsi_its_vam_ts_msgs/msg/vru_high_frequency_container.hpp>
namespace vam_ts_msgs = etsi_its_vam_ts_msgs::msg;
#endif


namespace etsi_its_vam_ts_conversion {

void toRos_VruHighFrequencyContainer(const vam_ts_VruHighFrequencyContainer_t& in, vam_ts_msgs::VruHighFrequencyContainer& out) {
  toRos_Wgs84Angle(in.heading, out.heading);
  toRos_Speed(in.speed, out.speed);
  toRos_LongitudinalAcceleration(in.longitudinalAcceleration, out.longitudinal_acceleration);
  if (in.curvature) {
    toRos_Curvature(*in.curvature, out.curvature);
    out.curvature_is_present = true;
  }
  if (in.curvatureCalculationMode) {
    toRos_CurvatureCalculationMode(*in.curvatureCalculationMode, out.curvature_calculation_mode);
    out.curvature_calculation_mode_is_present = true;
  }
  if (in.yawRate) {
    toRos_YawRate(*in.yawRate, out.yaw_rate);
    out.yaw_rate_is_present = true;
  }
  if (in.lateralAcceleration) {
    toRos_LateralAcceleration(*in.lateralAcceleration, out.lateral_acceleration);
    out.lateral_acceleration_is_present = true;
  }
  if (in.verticalAcceleration) {
    toRos_VerticalAcceleration(*in.verticalAcceleration, out.vertical_acceleration);
    out.vertical_acceleration_is_present = true;
  }
  if (in.vruLanePosition) {
    toRos_GeneralizedLanePosition(*in.vruLanePosition, out.vru_lane_position);
    out.vru_lane_position_is_present = true;
  }
  if (in.environment) {
    toRos_VruEnvironment(*in.environment, out.environment);
    out.environment_is_present = true;
  }
  if (in.movementControl) {
    toRos_VruMovementControl(*in.movementControl, out.movement_control);
    out.movement_control_is_present = true;
  }
  if (in.orientation) {
    toRos_Wgs84Angle(*in.orientation, out.orientation);
    out.orientation_is_present = true;
  }
  if (in.rollAngle) {
    toRos_CartesianAngle(*in.rollAngle, out.roll_angle);
    out.roll_angle_is_present = true;
  }
  if (in.deviceUsage) {
    toRos_VruDeviceUsage(*in.deviceUsage, out.device_usage);
    out.device_usage_is_present = true;
  }
}

void toStruct_VruHighFrequencyContainer(const vam_ts_msgs::VruHighFrequencyContainer& in, vam_ts_VruHighFrequencyContainer_t& out) {
  memset(&out, 0, sizeof(vam_ts_VruHighFrequencyContainer_t));
  toStruct_Wgs84Angle(in.heading, out.heading);
  toStruct_Speed(in.speed, out.speed);
  toStruct_LongitudinalAcceleration(in.longitudinal_acceleration, out.longitudinalAcceleration);
  if (in.curvature_is_present) {
    out.curvature = (vam_ts_Curvature_t*) calloc(1, sizeof(vam_ts_Curvature_t));
    toStruct_Curvature(in.curvature, *out.curvature);
  }
  if (in.curvature_calculation_mode_is_present) {
    out.curvatureCalculationMode = (vam_ts_CurvatureCalculationMode_t*) calloc(1, sizeof(vam_ts_CurvatureCalculationMode_t));
    toStruct_CurvatureCalculationMode(in.curvature_calculation_mode, *out.curvatureCalculationMode);
  }
  if (in.yaw_rate_is_present) {
    out.yawRate = (vam_ts_YawRate_t*) calloc(1, sizeof(vam_ts_YawRate_t));
    toStruct_YawRate(in.yaw_rate, *out.yawRate);
  }
  if (in.lateral_acceleration_is_present) {
    out.lateralAcceleration = (vam_ts_LateralAcceleration_t*) calloc(1, sizeof(vam_ts_LateralAcceleration_t));
    toStruct_LateralAcceleration(in.lateral_acceleration, *out.lateralAcceleration);
  }
  if (in.vertical_acceleration_is_present) {
    out.verticalAcceleration = (vam_ts_VerticalAcceleration_t*) calloc(1, sizeof(vam_ts_VerticalAcceleration_t));
    toStruct_VerticalAcceleration(in.vertical_acceleration, *out.verticalAcceleration);
  }
  if (in.vru_lane_position_is_present) {
    out.vruLanePosition = (vam_ts_GeneralizedLanePosition_t*) calloc(1, sizeof(vam_ts_GeneralizedLanePosition_t));
    toStruct_GeneralizedLanePosition(in.vru_lane_position, *out.vruLanePosition);
  }
  if (in.environment_is_present) {
    out.environment = (vam_ts_VruEnvironment_t*) calloc(1, sizeof(vam_ts_VruEnvironment_t));
    toStruct_VruEnvironment(in.environment, *out.environment);
  }
  if (in.movement_control_is_present) {
    out.movementControl = (vam_ts_VruMovementControl_t*) calloc(1, sizeof(vam_ts_VruMovementControl_t));
    toStruct_VruMovementControl(in.movement_control, *out.movementControl);
  }
  if (in.orientation_is_present) {
    out.orientation = (vam_ts_Wgs84Angle_t*) calloc(1, sizeof(vam_ts_Wgs84Angle_t));
    toStruct_Wgs84Angle(in.orientation, *out.orientation);
  }
  if (in.roll_angle_is_present) {
    out.rollAngle = (vam_ts_CartesianAngle_t*) calloc(1, sizeof(vam_ts_CartesianAngle_t));
    toStruct_CartesianAngle(in.roll_angle, *out.rollAngle);
  }
  if (in.device_usage_is_present) {
    out.deviceUsage = (vam_ts_VruDeviceUsage_t*) calloc(1, sizeof(vam_ts_VruDeviceUsage_t));
    toStruct_VruDeviceUsage(in.device_usage, *out.deviceUsage);
  }
}

}
